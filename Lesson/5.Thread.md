# Thread
---
## 1. Overview 

Threads are execution units within a process that enable concurrent task execution. Similar to processes, threads allow multi-tasking but with lower overhead in memory and CPU usage. In a multi-core system, multiple threads can run in parallel, improving performance. If one thread is blocked, others can continue executing independently.


**Benefits:**

Concurrency: Perform multiple tasks at once (e.g., downloading while updating UI).
Responsiveness: UI remains responsive while background work runs.
Performance: On multi-core CPUs, threads can run in parallel.

--- 

## 2. Principle of operation

Similar to processes, threads are created for the purpose of handling multiple tasks at the same time (multi-task).

- A thread is a lightweight process that can be managed independently by a scheduler.
- On a multi-core system. Multiple threads can run in parallel.
- If one thread is blocked, the other threads can continue to run normally.
- Each time a thread is created, it is placed in a stack segment.

**Context Switching** 

The CPU switches between threads, allowing multiple tasks to proceed concurrently. This involves saving and restoring thread states, leading to some overhead.

---

## 3. Compare Process with Thread

**Thread Switching**

Thread switching is a type of context switching from one thread to another thread in the same process.

Thread switching is very efficient and much cheaper because it involves switching out only identities and resources such as the program counter, registers and stack pointers. 

The cost of thread-to-thread switching is about the same as the cost of entering and exiting the kernel.

**Process Switching**

Process switching is a type of context switching where we switch one process with another process. 

 It involves switching of all the process resources with those needed by a new process. 
 
This means switching the memory address space. This includes memory addresses, page tables, and kernel resources, caches in the processor. 

| **Aspect**            | **Thread**                                                            | **Process**                                                             |
| --------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| **Definition**        | Smallest unit of execution within a process                           | Independent program in execution                                        |
| **Memory**            | Shares memory space with other threads of the same process            | Has its own separate memory space                                       |
| **Communication**     | Faster – via shared memory (no IPC needed)                            | Slower – requires Inter-Process Communication (IPC) like pipes, sockets |
| **Creation Overhead** | Low – faster to create                                                | High – more resources and time needed                                   |
| **Context Switching** | Faster – less overhead (threads share resources)                      | Slower – involves switching entire memory context                       |
| **Crash Impact**      | If one thread crashes, it can affect the whole process                | If a process crashes, other processes are usually unaffected            |
| **Control**           | Controlled by the parent process                                      | Managed independently by the OS                                         |
| **Use Case**          | Lightweight tasks within the same app (e.g. UI thread, worker thread) | Independent apps (e.g. Chrome, Word, Calculator)                        |

---

## 4. Working with thread

### 4.1 Thread ID

A process is identified by a process ID, a thread within a process is identified by a thread ID. 

- A process ID is unique across the system, whereas a thread ID is unique within a process. 
- A process ID is an integer value, but a thread ID does not have to be an integer value. It can be a structure. 
- A process ID can be printed very easily, whereas a thread ID cannot.

Thread ID will be represented by the type `pthread_t`. 

In most cases thread ID will be a structure so to compare two thread IDs we need a function that can do this job (For process ID is an integer, the comparison is simpler). 

To do this we use the following two functions: `pthread_self()` and `pthread_equal()`

- `pthread_self()`: Retrieves the calling thread's ID.
  
- `pthread_equal()`: Compares two thread IDs.

### 4.2 Create thread 

`int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *),void *arg);`

| **Parameter**                    | **Description**                                                                                            |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| `pthread_t *thread`              | Output: stores the **ID** of the newly created thread.                                                     |
| `const pthread_attr_t *attr`     | Optional. If `NULL`, default attributes are used (joinable, etc.). Otherwise, custom thread attributes.    |
| `void *(*start_routine)(void *)` | Function pointer – the **function the new thread will run**. It must take a `void *` and return `void *`.  |
| `void *arg`                      | Argument passed to `start_routine`. Can be `NULL` or a pointer to any data you want to pass to the thread. |


`pthread_join()` 

Waits for a specific thread to finish.

It blocks the calling thread until the target thread terminates.

| Parameter          | Description                                                                                                   |
| ------------------ | ------------------------------------------------------------------------------------------------------------- |
| `pthread_t thread` | The thread ID (returned from `pthread_create()`) that you want to wait for.                                   |
| `void **retval`    | A pointer to a `void*` where the return value from the thread will be stored. If you don’t care, pass `NULL`. |

**Code demo**

```c
#include <pthread.h>
#include <stdio.h>
void *thread_function(void *arg) {
    pthread_t tid = pthread_self();
    printf("Thread ID: %lu\n", (unsigned long)tid);
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    pthread_create(&thread1, NULL, thread_function, NULL);
    pthread_create(&thread2, NULL, thread_function, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    return 0;
}
```

**Output**

```sh
Thread ID: 130023310751296
Thread ID: 130023302358592
```
### 4.3 Thread management

#### 4.3.1 `int pthread_exit(void *retval);`


A thread can be terminated by calling `pthread_exit()`. 

**Arguments: **

- *retval: Specifies the return value of the thread, which can be obtained by another thread via `pthread_join()`. 

- Returns 0 on success, less than 0 on failure.

#### 4.3.2 int pthread_cancel(pthread_t thread);


`pthread_cancel()` sends a thread termination request to a specified thread.

**Arguments:**

- thread: the threadID of the specified thread.

- Returns 0 on success, less than 0 on failure.

**Thread termination methods**

| Method                      | Description                       | Return Value Accessible  |
| --------------------------- | --------------------------------- | ------------------------ |
| `return`                    | Normal exit from thread function  | Yes (via `pthread_join`) |
| `pthread_exit()`            | Graceful exit with a return value | Yes                      |
| `pthread_cancel()`          | Asks another thread to stop       | Depends on cancel state  |
| `exit()` or end of `main()` | Ends all threads                  | No                       |


#### 4.3.3 Joinable thread 

To get the end value of another thread we use `pthread_join()`.

`int pthread_join(pthread_t thread, void **retval);`

`pthread_join()` will block until a thread terminates (threadID is passed in the thread argument). If the thread has terminated, pthread_join returns immediately. 

When the thread terminates, it is basically treated as a zombie process. If the number of zombie threads increases. At some point, we will not be able to create more threads. The role of `pthread_join()` is similar to `waitpid()`.

#### 4.3.4 Detaching thread

By default, a thread is joinable, meaning that when a thread terminates, another thread can obtain the return value of that thread via `pthread_join()`.

However, in many cases we do not need to care about the termination state of the thread, but only need the system to automatically clean and remove the thread.

In this case, we can put the thread into detached state by calling `pthread_detached()`.

`int pthread_detach(pthread_t thread);`

Once a thread is detached, we cannot use pthread_join() to obtain the thread's termination status, and the thread cannot return to the joinable state.

**Arguments:**

- thread: ThreadID of the specified thread.

- Returns 0 on success, less than 0 on failure.

## 5. Theard synchronization

### 5.1 Synchronization issues

- Race condition: Occurs when multiple threads access shared resources without proper synchronization (atomic and nonatomic).
  
- Deadlock: Occurs when multiple threads wait for each other to release resources, causing indefinite blocking.
  
- Critical Section: A section of code that must be executed by only one thread at a time to prevent race conditions.

### 5.2 Mutex (mutual exclusion)

Mutex (mutual exclusion) is a technique used to ensure that only one thread has access to shared resources at a time.

Mutex implementation generally involves three steps:

- Initialize mutex lock
- Implement mutex lock for shared resources before entering critical section.
- Implement access to shared resources.
- Unlock/release mutex lock.

Allocate Mutexs

The mutex lock is a variable of type pthread_mutex_t. Before using it, we must always initialize the mutex lock.

The mutex lock can be allocated statically or dynamically

`pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);`

When not in use, we must destroy the mutex with pthread_mutex_destroy(). Static initialization does not require calling this function.

### 5.3 Locking and Unlocking a Mutex

After initialization, the mutex lock falls into the unlocked state. 

To lock or unlock a mutex lock, we use two functions pthread_mutex_lock() and pthread_mutex_unlock().

`int pthread_mutex_lock(pthread_mutex_t *mutex);`

When the mutex lock is unlocked, pthread_mutex_lock() returns immediately. Conversely, if the mutex is locked by another thread, pthread_mutex_lock() blocks until the mutex is unlocked.

**Arguments:**

- *mutex: Pointer to the mutex lock
- Returns 0 on success, less than 0 on failure.

`int pthread_mutex_unlock(pthread_mutex_t *mutex);`

Unlock a mutex lock.

**Arguments:**

- *mutex: Pointer to mutex lock
- Returns 0 on success, less than 0 on failure.

### 5.4 Condition variables

A mutex is used to access shared variables at the same time. 

A condition variable is used to notify another thread of a change to a shared variable and allow another thread to block until it receives the notification.

Condition variable is a variable of type `pthread_cond_t`. Before using it, we must always initialize it.

Condition variable can be allocated statically or dynamically.

`pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr); `

When not in use, we must destroy the condition variable with `pthread_cond_destroy()`. Static initialization does not require calling this function.




