# Semaphore

## 1 Introduction 

### 1.1 What is semaphore
Semaphore is a mechanism that allows synchronization of access between processes and threads.

Its main purpose is to block processes and threads from accessing a shared memory area that is being used by another process/thread.

There are 2 types of semaphore that are mainly used:
  - System V semaphore
  - POSIX semaphore

## 1.2 Semaphore type

Defined by SUSv3, POSIX semaphores come in two types:

**Named Semaphores:**

These are semaphores that have a name and are created or opened using the sem_open() function. They can be accessed by unrelated processes, allowing multiple processes to synchronize using the same named semaphore.

**Unnamed Semaphores:**

These semaphores do not have a name, so they cannot be shared using a global identifier. To be used across processes or threads, they must be placed in a shared memory region (such as one created with `mmap()`, or stored in a global/shared variable).

POSIX semaphores are used to coordinate access between processes or threads.

For processes, the semaphore must be stored in a shared memory region (using System V shared memory or POSIX `mmap())`.

For threads, the semaphore should be stored in a shared memory area internal to the program, such as a global variable or heap-allocated structure, since all threads of a process share the same address space.

## 2. Core Semaphore Concepts and Operations

### 2.1 How semaphore work

A semaphore is an integer maintained by the kernel, whose value is restricted to be **greater than or equal to zero**.

Various operations (i.e., system calls) can be performed on a semaphore, including the following:
  - Increase the current value of the semaphore by 1 using `sem_post()`.
  - Decrease the current value of the semaphore by 1 using `sem_wait()`.
  - Read the current value of the semaphore.

<img width="869" height="678" alt="image" src="https://github.com/user-attachments/assets/847ce38a-4c68-4976-882e-82c0430d23b7" />

### 2.2 Waiting on semaphore

```c
int sem_wait(sem_t *sem);
```

`sem_wait()` is used to decrement (or "lock") a semaphore.

If the semaphore's value is greater than 0, it decrements the value by 1 and continues.

If the value is 0, the function blocks (waits) until the semaphore becomes greater than 0.

This is how it controls access to a shared resource, ensuring that only a limited number of processes/threads can access the critical section at once.

```c
int sem_trywait(sem_t *sem);
```

`sem_trywait()` is a non-blocking version of `sem_wait()`.

It tries to decrement the semaphore immediately.

If the value is > 0, it decrements the value and proceeds.

If the value is 0, it returns immediately with an error, instead of blocking.

**Use Case**

Use `sem_trywait()` when you don’t want your thread/process to block if the resource is busy.

```c
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

**Purpose:**

`sem_timedwait()` blocks (like `sem_wait()`), but only up to a specified timeout.

If the semaphore becomes available before the timeout, it decrements the value and continues.

If the timeout expires, it returns with an error (ETIMEDOUT).

Prevents indefinite blocking.

**Comparision of 3 function**

| Feature                    | `sem_wait()`                                      | `sem_trywait()`                                 | `sem_timedwait()`                                             |
| -------------------------- | ------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------- |
| **Blocking**               | ✅ Yes (blocks indefinitely)                       | ❌ No (non-blocking)                             | ✅ Yes (but with a time limit)                                 |
| **Timeout support**        | ❌ No                                              | ❌ No                                            | ✅ Yes (uses absolute time)                                    |
| **When it fails**          | Only on error (e.g., invalid semaphore)           | If value is 0, returns immediately              | If timeout expires or error occurs                            |
| **Typical `errno`**        | `EINTR`, `EINVAL`                                 | `EAGAIN`, `EINVAL`                              | `ETIMEDOUT`, `EINTR`, `EINVAL`                                |
| **Use case**               | You want to wait until the semaphore is available | You want to check availability without blocking | You want to wait for the resource but only up to a time limit |
| **Return value (success)** | `0`                                               | `0`                                             | `0`                                                           |
| **Return value (failure)** | `-1` with `errno` set                             | `-1` with `errno` set                           | `-1` with `errno` set                                         |
| **Real-time safe?**        | ❌ Can block indefinitely                          | ✅ Preferred for RT when fallback needed         | ✅ Useful in RT with predictable time budget                   |

**Summary:**
  - Use `sem_wait()`: When you’re okay waiting as long as needed.
  - Use `sem_trywait()`: When you want to avoid blocking (e.g., in a GUI, real-time system).
  - Use `sem_timedwait()`: When you need a timeout-safe wait with a fallback strategy.

### 2.3 Posting on semaphore

```c
int sem_post(sem_t *sem);
```

The sem_post() function increases (increases by 1) the value of the semaphore.

If the value of the semaphore is 0, then increase the value of the semaphore value by 1. Then the processes waiting for sem_wait() will be awakened.

If there are many processes waiting, the kernel uses the round-robin, time-sharing algorithm to decide.

That is, the process that waits first will not be executed first, but after sem_post(), the process that is the next time slot (time slice) of the CPU will be executed.


