# Message Queue

## 1. Overview

A message queue is a communication method used in inter-process communication (IPC) or distributed systems that allows independent processes, threads, or systems to send and receive messages asynchronously.

A Message Queue is a linked-list of messages maintained by the kernel.

All processes can exchange data by accessing the same queues.

Each message is accompanied by additional information about the message type.

<img width="1072" height="527" alt="image" src="https://github.com/user-attachments/assets/304027c2-61aa-42fa-81de-fc6239b53cd2" />

Based on the message type, processes can retrieve the appropriate message.

<img width="1072" height="721" alt="image" src="https://github.com/user-attachments/assets/d8a50111-3034-4763-b40f-29a6dc2f56be" />

## 2. System V Message Queues

System V message queues are a traditional IPC mechanism using integer keys. They’re less common in modern embedded Linux due to complexity but may appear in legacy codebases.

### 2.1. Implementation Steps

1. Create a key.
2. Create or open a message queue.
3. Write data to the queue.
4. Read data from the queue.
5. Release the queue to prevent resource leaks.

**Embedded Note**: Always remove queues with `IPC_RMID` to avoid persistent resources, as embedded devices may reboot frequently, leaving stale queues.

### 2.2. Creating a Key

Use `ftok()` to generate a unique key:

```c
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj);
```

- **Parameters**:
    - `pathname`: Existing, accessible file (e.g., `/tmp/myfile`).
    - `proj`: Project identifier (e.g., 'A').
- **Returns**: Integer key or -1 on error.
- Combines file inode and project ID for uniqueness.

### 2.3. Creating a Message Queue

Use `msgget()` to create or open a queue:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
```

- **Parameters**:
    - `key`: From `ftok()`.
    - `msgflg`: Flags like `IPC_CREAT` (create if non-existent), `IPC_EXCL` (fail if exists), and permissions (e.g., 0666).
- **Returns**: Queue ID or -1 on error.

### 2.4. Writing to a Message Queue

Use `msgsnd()` to send a message:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

- **Parameters**:
    - `msqid`: Queue ID from `msgget()`.
    - `msgp`: Pointer to a `struct msgbuf`:
        
        ```c
        struct msgbuf {
            long mtype;     /* message type, must be > 0 */
            char mtext[1];  /* message data */
        };
        ```
        
    - `msgsz`: Size of `mtext` (excludes `mtype`).
    - `msgflg`: `IPC_NOWAIT` (non-blocking) or 0 (block until space).
- **Returns**: 0 on success, -1 on error (e.g., `ENOSPC` if queue is full).

### 2.5. Reading from a Message Queue

Use `msgrcv()` to receive a message:

```c
#include <sys/types.h>
#include <sys/msg.h>
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

- **Parameters**:
    - `msqid`: Queue ID.
    - `msgp`: Buffer for received message.
    - `msgsz`: Maximum size of `mtext`.
    - `msgtyp`: 0 (first message), >0 (specific type), <0 (lowest type ≤ |msgtyp|).
    - `msgflg`: `IPC_NOWAIT` (non-blocking), `MSG_NOERROR` (truncate oversized messages).
- **Returns**: Bytes copied to `mtext` or -1 on error (e.g., `EIDRM` if queue removed).

### 2.6. Controlling and Deleting a Message Queue

Use `msgctl()` for queue operations:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

- **Parameters**:
    - `msqid`: Queue ID.
    - `cmd**:` IPC_RMID`(remove queue),`IPC_STAT`(get info),`IPC_SET` (set attributes).
    - `buf`: Pointer to `msqid_ds`:
        
        ```c
        struct msqid_ds {
            struct ipc_perm msg_perm;   /* Permissions */
            time_t msg_stime;           /* Last msgsnd() time */
            time_t msg_rtime;           /* Last msgrcv() time */
            time_t msg_ctime;           /* Last change time */
            unsigned long msg_cbytes;   /* Bytes in queue */
            msgqnum_t msg_qnum;         /* Number of messages */
            msglen_t msg_qbytes;        /* Max bytes in queue */
            pid_t msg_lspid;            /* Last msgsnd() PID */
            pid_t msg_lrpid;            /* Last msgrcv() PID */
        };
        ```
        
- **Returns**: 0 on success, -1 on error.

