# Message Queue

## 1. Overview

A message queue is a communication method used in inter-process communication (IPC) or distributed systems that allows independent processes, threads, or systems to send and receive messages asynchronously.

A Message Queue is a linked-list of messages maintained by the kernel.

All processes can exchange data by accessing the same queues.

Each message is accompanied by additional information about the message type.

<img width="1072" height="527" alt="image" src="https://github.com/user-attachments/assets/304027c2-61aa-42fa-81de-fc6239b53cd2" />

Based on the message type, processes can retrieve the appropriate message.

<img width="1072" height="721" alt="image" src="https://github.com/user-attachments/assets/d8a50111-3034-4763-b40f-29a6dc2f56be" />

## 2. System V Message Queues

System V message queues are a traditional IPC mechanism using integer keys. They’re less common in modern embedded Linux due to complexity but may appear in legacy codebases.

### 2.1. Implementation Steps

1. Create a key.
2. Create or open a message queue.
3. Write data to the queue.
4. Read data from the queue.
5. Release the queue to prevent resource leaks.

**Embedded Note**: Always remove queues with `IPC_RMID` to avoid persistent resources, as embedded devices may reboot frequently, leaving stale queues.

### 2.2. Creating a Key

Use `ftok()` to generate a unique key:

```c
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj);
```

- **Parameters**:
    - `pathname`: Existing, accessible file (e.g., `/tmp/myfile`).
    - `proj`: Project identifier (e.g., 'A').
- **Returns**: Integer key or -1 on error.
- Combines file inode and project ID for uniqueness.

### 2.3. Creating a Message Queue

Use `msgget()` to create or open a queue:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
```

- **Parameters**:
    - `key`: From `ftok()`.
    - `msgflg`: Flags like `IPC_CREAT` (create if non-existent), `IPC_EXCL` (fail if exists), and permissions (e.g., 0666).
- **Returns**: Queue ID or -1 on error.

### 2.4. Writing to a Message Queue

Use `msgsnd()` to send a message:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

- **Parameters**:
    - `msqid`: Queue ID from `msgget()`.
    - `msgp`: Pointer to a `struct msgbuf`:
        
        ```c
        struct msgbuf {
            long mtype;     /* message type, must be > 0 */
            char mtext[1];  /* message data */
        };
        ```
        
    - `msgsz`: Size of `mtext` (excludes `mtype`).
    - `msgflg`: `IPC_NOWAIT` (non-blocking) or 0 (block until space).
- **Returns**: 0 on success, -1 on error (e.g., `ENOSPC` if queue is full).

### 2.5. Reading from a Message Queue

Use `msgrcv()` to receive a message:

```c
#include <sys/types.h>
#include <sys/msg.h>
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

- **Parameters**:
    - `msqid`: Queue ID.
    - `msgp`: Buffer for received message.
    - `msgsz`: Maximum size of `mtext`.
    - `msgtyp`: 0 (first message), >0 (specific type), <0 (lowest type ≤ |msgtyp|).
    - `msgflg`: `IPC_NOWAIT` (non-blocking), `MSG_NOERROR` (truncate oversized messages).
- **Returns**: Bytes copied to `mtext` or -1 on error (e.g., `EIDRM` if queue removed).

### 2.6. Controlling and Deleting a Message Queue

Use `msgctl()` for queue operations:

```c
#include <sys/types.h>
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

- **Parameters**:
    - `msqid`: Queue ID.
    - `cmd**:` IPC_RMID`(remove queue),`IPC_STAT`(get info),`IPC_SET` (set attributes).
    - `buf`: Pointer to `msqid_ds`:
        
        ```c
        struct msqid_ds {
            struct ipc_perm msg_perm;   /* Permissions */
            time_t msg_stime;           /* Last msgsnd() time */
            time_t msg_rtime;           /* Last msgrcv() time */
            time_t msg_ctime;           /* Last change time */
            unsigned long msg_cbytes;   /* Bytes in queue */
            msgqnum_t msg_qnum;         /* Number of messages */
            msglen_t msg_qbytes;        /* Max bytes in queue */
            pid_t msg_lspid;            /* Last msgsnd() PID */
            pid_t msg_lrpid;            /* Last msgrcv() PID */
        };
        ```
        
- **Returns**: 0 on success, -1 on error.

## 3. POSIX Message Queues

POSIX message queues offer a modern, file-like API with priority support, making them ideal for embedded systems, especially real-time applications.

### 3.1. Implementation Steps

1. Create or open a message queue.
2. Write data to the queue.
3. Read data from the queue.
4. Close the queue.
5. Remove the queue when no longer needed.

**Embedded Note**: Tune `mq_maxmsg` and `mq_msgsize` (e.g., 10 messages, 128 bytes) to conserve memory in resource-constrained devices.

### 3.2. Opening a Message Queue

Use `mq_open()` to create or open a queue:

```c
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>
mqd_t mq_open(const char *name, int oflag);
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
```

- **Parameters**:
    - `name`: Queue name (e.g., `/myqueue`).
    - `oflag**:` O_CREAT`,` O_EXCL`,` O_RDONLY`,` O_WRONLY`,` O_RDWR`,` O_NONBLOCK`.
    - `mode`: Permissions (e.g., 0660) for new queues.
    - `attr`: Queue attributes or NULL for defaults.
- **Returns**: Queue descriptor or (mqd_t)-1 on error.
- **Attributes**:

```c
struct mq_attr {
    long mq_flags;    /* Flags: 0 or O_NONBLOCK */
    long mq_maxmsg;   /* Max number of messages */
    long mq_msgsize;  /* Max message size (bytes) */
    long mq_curmsgs;  /* Current number of messages */
};
```

**Embedded Note**: POSIX queues appear in `/dev/mqueue`, so verify filesystem limits via `/proc/sys/fs/mqueue/msg_max`.

### 3.3. Sending a Message

Use `mq_send()` to send a message:

```c
#include <mqueue.h>
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
```

- **Parameters**:
    - `mqdes`: Queue descriptor.
    - `msg_ptr`: Message buffer.
    - `msg_len`: Message length (≤ `mq_msgsize`).
    - `msg_prio`: Priority (higher = more urgent).
- **Returns**: 0 on success, -1 on error.
- Messages with equal priority are FIFO-ordered.

### 3.4. Receiving a Message

Use `mq_receive()` to read a message:

```c
#include <mqueue.h>
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
```

- **Parameters**:
    - `mqdes`: Queue descriptor.
    - `msg_ptr`: Buffer for message.
    - `msg_len`: Buffer size (≥ `mq_msgsize`).
    - `msg_prio`: Stores received message priority (or NULL).
- **Returns**: Bytes received or -1 on error.
- Always retrieves the highest-priority message.

### 3.5. Closing a Message Queue

Use `mq_close()` to close a queue:

```c
#include <mqueue.h>
int mq_close(mqd_t mqdes);
```

- **Parameters**: `mqdes` from `mq_open()`.
- **Returns**: 0 on success, -1 on error.
- Doesn’t remove the queue; other processes can still access it.

### 3.6. Removing a Message Queue

Use `mq_unlink()` to delete a queue:

```c
#include <mqueue.h>
int mq_unlink(const char *name);
```

- **Parameters**: Queue name.
- **Returns**: 0 on success, -1 on error.
- Queue persists until all descriptors are closed.****
