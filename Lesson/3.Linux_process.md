# Linux process
## 1. What is Program & Process
### 1.1 Program
Program is a group of instruction that perform a specific task, which can ve performed by exectuable files and located on the computer's hard drive.

### 1.2 Process
Process is a program that is executing and using system resources.

Each process has a code that is used to identify it called Process ID (PID), which is a positive and unique integer for each process on the system.


| **Program**                                             | **Process**                                 |
|-----------------------------------------------------------|--------------------------------------------|
| The program contains a set of instructions designed to complete a specific task.  |The process is an instance of an executing program.        | 
|A program is a passive entity as it resides in the secondary memory.|The process is an active entity as it is created during execution and loaded into the main memory.|
| Program exists at a single place and continues to exist until it is deleted. |The process exists for a limited period as it gets terminated after the completion of the task.|
| A program is a static entity.|The process is a dynamic entity.| 
| The program does not have any resource requirement, it only requires memory space for storing the instructions.| The process has a high resource requirement, it needs resources like CPU, memory address, and I/O during its lifetime. |
| Stored as a file (.exe, .py, .jar, etc.) Does not consume CPU or RAM until it‚Äôs executed| Uses CPU and memory (RAM), Created and managed by the operating system|
|One program can create multiple processes|Each process is independent|

**Show all process in system**

```sh
ps -aux
```



## 2 Command line argument
Every program starts from main.

There are two common ways to declare the **main()** function in C.

Type 1:
```sh
int main(void)
```

Type 2:
```sh
int main(int argc, char *argv[])
```

When running the program, the enviroment parameters(commmand line arguments) will be passed as two arguments in the main():
- **argc** (Number of parameters passed to main function.
- **argv[]** (Array of pointers point to the parameters passed to that program.

**Code demo**
```sh
#include <stdio.h>
#include <stdlib.h>

void main(int argc, char *argv[]) 
{   
    int i;

    // In ra s·ªë l∆∞·ª£ng command-line truy·ªÅn v√†o.
    printf("Number of arguments: %d\n", argc);    
    
    // In ra n·ªôi dung c·ªßa m·ªói command-line.
    for (i = 0; i < argc; i++) {
        printf("argc[%d]: %s\n", i+1, argv[i]);
    }
}
```

**Input**
```sh
./app Linux Messi Khanh
```

**Output** 
```sh
Number of arguments: 4
argc[1]: ./fork
argc[2]: linux
argc[3]: Messi
argc[4]: Khanh
```

üí° **Tip**
Use **strace** to debug
```sh
strace ./app Linux Messi Khanh
```



## 3. Memory layout
The memory allocated for each process is divide into different part. Usually they are called segments (memeory partitions)
![image](https://github.com/user-attachments/assets/19d58eb9-deee-401d-a63c-1c52641f7bc0)

### 3.1 Text segment 
Text segment contains the machine language instruction of the program.

This segment has read-only permissions. Typically the lowest address region after the OS-reserved memory

### 3.2 Initialized data segment
Initialized data segment includes global variables and static variables that have been explicity initialized.

This segment has read and write permissions

### 3.3 Uninitialized data segment
Uninitialized data segment includes global variables and static variables that have been implicity initialized.

This segment has read and write permissions

### 3.4 Heap segment 
Heap segment are for automatic memory allocation. Use functions like alloc(), malloc(), calloc()

The endpoint of the Heap is called a program break

This segment has read and write permissions
### 3.5 Stack segment 
Stack can be extending by allocating or freeing stack frames.

This segment has read and write permissions

üí° **How to check when memory leak**
Valgrind is a dynamic analysis tool primarily used for: detecting memory errors, debugging memory leaks, finding undefined behavior in C/C++ programs

**Example check memory leak**
``sh
#include <stdlib.h>

int main() {
    int *ptr = malloc(10 * sizeof(int));
    // forget to free(ptr)
    return 0;
}
``

**Compile and run**
``sh
gcc -c main.c -o app
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt ./app 
cat valgrind-out.txt
``



## 4. Operation on process
### 4.1 System call ``fork()``
The ``fork()`` system call is used in Unix/Linux to create a new process by duplicating the current process.







